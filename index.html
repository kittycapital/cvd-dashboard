<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>거래소별 CVD Dashboard | Herdvibe</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/2.0.1/chartjs-plugin-zoom.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@700;900&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  :root {
    --bg-primary: #0a0a0f;
    --bg-secondary: #12121a;
    --bg-card: #16161f;
    --bg-hover: #1e1e2a;
    --border: #252535;
    --text-primary: #e8e8ef;
    --text-secondary: #8888a0;
    --text-muted: #55556a;
    --accent-green: #00e676;
    --accent-red: #ff1744;
    --accent-blue: #448aff;
    --accent-purple: #b388ff;
    --accent-orange: #ff9100;
  }
  body {
    background: var(--bg-primary);
    color: var(--text-primary);
    font-family: 'JetBrains Mono', monospace;
    min-height: 100vh;
    overflow-x: hidden;
  }
  .header {
    display: flex; flex-direction: column; align-items: center;
    padding: 20px 24px 16px;
    border-bottom: 1px solid var(--border);
    background: var(--bg-secondary); gap: 12px;
  }
  .header-title {
    font-family: 'Noto Sans KR', sans-serif;
    font-size: 22px; font-weight: 900;
    letter-spacing: 2px; color: var(--text-primary);
  }
  .coin-tabs {
    display: flex; gap: 4px;
    background: var(--bg-primary); padding: 3px; border-radius: 8px;
  }
  .coin-tab {
    padding: 8px 20px; border: none; background: transparent;
    color: var(--text-secondary); font-family: 'JetBrains Mono', monospace;
    font-size: 13px; font-weight: 500; cursor: pointer;
    border-radius: 6px; transition: all 0.2s; letter-spacing: 1px;
  }
  .coin-tab:hover { color: var(--text-primary); background: var(--bg-hover); }
  .coin-tab.active { background: var(--accent-green); color: #000; font-weight: 700; }
  .status-bar { display: flex; align-items: center; gap: 12px; }
  .status-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--accent-red); transition: background 0.3s;
  }
  .status-dot.connected {
    background: var(--accent-green);
    box-shadow: 0 0 8px var(--accent-green);
    animation: pulse 2s infinite;
  }
  @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.5} }
  .status-text { font-size: 11px; color: var(--text-muted); }
  .dashboard { padding: 16px 24px; display: flex; flex-direction: column; gap: 12px; }
  .chart-card {
    background: var(--bg-card); border: 1px solid var(--border);
    border-radius: 12px; padding: 16px; position: relative; overflow: hidden;
  }
  .section-header {
    display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;
  }
  .section-title {
    font-size: 11px; color: var(--text-muted);
    letter-spacing: 2px; text-transform: uppercase;
  }
  .price-display { display: flex; align-items: baseline; gap: 12px; }
  .current-price { font-size: 28px; font-weight: 700; color: var(--text-primary); }
  .price-change { font-size: 13px; font-weight: 500; }
  .price-change.up { color: var(--accent-green); }
  .price-change.down { color: var(--accent-red); }
  .chart-container { position: relative; height: 200px; }
  .cvd-chart-container { position: relative; height: 280px; }
  .watermark {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'JetBrains Mono', monospace;
    font-size: 40px; font-weight: 700;
    color: rgba(255,255,255,0.03);
    pointer-events: none; letter-spacing: 4px;
    white-space: nowrap; z-index: 1;
  }
  .exchange-legend { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
  .legend-item {
    display: flex; align-items: center; gap: 6px;
    padding: 4px 10px; background: var(--bg-primary);
    border-radius: 6px; font-size: 11px;
    border: 1px solid var(--border); transition: opacity 0.2s; cursor: pointer;
  }
  .legend-item:hover { border-color: var(--text-muted); }
  .legend-item.hidden { opacity: 0.3; }
  .legend-dot { width: 10px; height: 10px; border-radius: 3px; }
  .legend-name { color: var(--text-secondary); }
  .legend-value { font-weight: 600; min-width: 80px; text-align: right; }
  .legend-value.positive { color: var(--accent-green); }
  .legend-value.negative { color: var(--accent-red); }
  .info-row { display: flex; gap: 24px; flex-wrap: wrap; }
  .info-card {
    background: var(--bg-card); border: 1px solid var(--border);
    border-radius: 12px; padding: 16px; flex: 1; min-width: 180px;
  }
  .info-label {
    font-size: 10px; color: var(--text-muted);
    letter-spacing: 2px; text-transform: uppercase; margin-bottom: 6px;
  }
  .info-value { font-size: 18px; font-weight: 600; }
  .info-value.positive { color: var(--accent-green); }
  .info-value.negative { color: var(--accent-red); }
  .controls-row { display: flex; align-items: center; gap: 8px; }
  .timeframe-btn {
    padding: 5px 12px; border: 1px solid var(--border);
    background: transparent; color: var(--text-secondary);
    font-family: 'JetBrains Mono', monospace; font-size: 11px;
    cursor: pointer; border-radius: 4px; transition: all 0.2s;
  }
  .timeframe-btn:hover { border-color: var(--text-muted); color: var(--text-primary); }
  .timeframe-btn.active { background: var(--accent-blue); color: #fff; border-color: var(--accent-blue); }
  .reset-btn {
    padding: 5px 12px; border: 1px solid var(--accent-red);
    background: transparent; color: var(--accent-red);
    font-family: 'JetBrains Mono', monospace; font-size: 11px;
    cursor: pointer; border-radius: 4px; margin-left: auto; transition: all 0.2s;
  }
  .reset-btn:hover { background: var(--accent-red); color: #000; }
  .loading-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(10,10,15,0.85);
    display: flex; align-items: center; justify-content: center;
    z-index: 10; border-radius: 12px;
    font-size: 12px; color: var(--text-secondary); letter-spacing: 1px;
  }
  .loading-overlay.hidden { display: none; }
  .footer {
    padding: 12px 24px; text-align: center;
    font-size: 10px; color: var(--text-muted);
    border-top: 1px solid var(--border); letter-spacing: 1px;
  }
  @media (max-width: 768px) {
    .header { flex-direction: column; gap: 12px; padding: 12px 16px; }
    .dashboard { padding: 12px 16px; }
    .current-price { font-size: 22px; }
    .chart-container { height: 160px; }
    .cvd-chart-container { height: 220px; }
    .info-row { gap: 8px; }
    .info-card { min-width: 140px; padding: 12px; }
    .watermark { font-size: 28px; }
  }
</style>
</head>
<body>

<div class="header">
  <div class="header-title">거래소별 CVD</div>
  <div class="coin-tabs">
    <button class="coin-tab active" data-coin="BTC">BTC</button>
    <button class="coin-tab" data-coin="ETH">ETH</button>
    <button class="coin-tab" data-coin="SOL">SOL</button>
  </div>
  <div class="status-bar">
    <div class="status-dot" id="statusDot"></div>
    <span class="status-text" id="statusText">연결 중...</span>
  </div>
</div>

<div class="dashboard">
  <div class="chart-card">
    <div class="watermark">Herdvibe.com</div>
    <div id="priceLoading" class="loading-overlay">과거 데이터 로딩 중...</div>
    <div class="section-header">
      <span class="section-title" id="priceLabel">BTC/USDT · Binance Reference</span>
      <div class="price-display">
        <span class="current-price" id="currentPrice">--</span>
        <span class="price-change" id="priceChange">--</span>
      </div>
    </div>
    <div class="chart-container"><canvas id="priceChart"></canvas></div>
  </div>

  <div class="controls-row">
    <span style="font-size:10px;color:var(--text-muted);letter-spacing:1px;">집계 간격:</span>
    <button class="timeframe-btn" data-bucket="5">5s</button>
    <button class="timeframe-btn" data-bucket="15">15s</button>
    <button class="timeframe-btn active" data-bucket="30">30s</button>
    <button class="timeframe-btn" data-bucket="60">1m</button>
    <button class="reset-btn" id="resetBtn">CVD 리셋</button>
  </div>

  <div class="chart-card">
    <div class="watermark">Herdvibe.com</div>
    <div id="cvdLoading" class="loading-overlay">과거 데이터 로딩 중...</div>
    <div class="section-header">
      <span class="section-title">거래소별 CVD (Cumulative Volume Delta)</span>
    </div>
    <div class="cvd-chart-container"><canvas id="cvdChart"></canvas></div>
    <div class="exchange-legend" id="exchangeLegend"></div>
  </div>

  <div class="info-row">
    <div class="info-card">
      <div class="info-label">합산 CVD</div>
      <div class="info-value" id="totalCvd">$0</div>
    </div>
    <div class="info-card">
      <div class="info-label">최대 매수 압력</div>
      <div class="info-value positive" id="topBuyer">--</div>
    </div>
    <div class="info-card">
      <div class="info-label">최대 매도 압력</div>
      <div class="info-value negative" id="topSeller">--</div>
    </div>
    <div class="info-card">
      <div class="info-label">체결 수 (세션)</div>
      <div class="info-value" id="tradeCount" style="color:var(--accent-blue)">0</div>
    </div>
  </div>
</div>

<div class="footer">HERDVIBE.COM · Real-time CVD from Exchange WebSocket APIs</div>

<script>
// ============================================================
// CONFIG
// ============================================================
const EXCHANGES = {
  binance:  { name: 'Binance',  color: '#F0B90B' },
  bybit:    { name: 'Bybit',    color: '#ff9100' },
  kraken:   { name: 'Kraken',   color: '#b388ff' },
  coinbase: { name: 'Coinbase', color: '#448aff' },
};

const COINS = {
  BTC: {
    binance:  { ws: 'btcusdt@trade',      rest: 'BTCUSDT' },
    bybit:    { ws: 'publicTrade.BTCUSDT', rest: 'BTCUSDT' },
    kraken:   { ws: 'BTC/USD',             rest: 'XBTUSD' },
    coinbase: { ws: 'BTC-USD',             rest: 'BTC-USD' },
  },
  ETH: {
    binance:  { ws: 'ethusdt@trade',       rest: 'ETHUSDT' },
    bybit:    { ws: 'publicTrade.ETHUSDT', rest: 'ETHUSDT' },
    kraken:   { ws: 'ETH/USD',             rest: 'ETHUSD' },
    coinbase: { ws: 'ETH-USD',             rest: 'ETH-USD' },
  },
  SOL: {
    binance:  { ws: 'solusdt@trade',       rest: 'SOLUSDT' },
    bybit:    { ws: 'publicTrade.SOLUSDT', rest: 'SOLUSDT' },
    kraken:   { ws: 'SOL/USD',             rest: 'SOLUSD' },
    coinbase: { ws: 'SOL-USD',             rest: 'SOL-USD' },
  },
};

// ============================================================
// STATE
// ============================================================
let activeCoin = 'BTC';
let bucketSeconds = 30;
let sockets = {};
let rawTrades = {};
let cvdData = {};
let hiddenExchanges = new Set();
let connectedCount = 0;
let currentPrice = 0;
let startPrice = 0;
let tradeCount = 0;

const MAX_RAW = 50000;
const MAX_PTS = 600;

// ============================================================
// HELPERS
// ============================================================
function fmt$(v) {
  const a = Math.abs(v), s = v < 0 ? '-' : '';
  if (a >= 1e9) return s+'$'+(a/1e9).toFixed(2)+'B';
  if (a >= 1e6) return s+'$'+(a/1e6).toFixed(2)+'M';
  if (a >= 1e3) return s+'$'+(a/1e3).toFixed(1)+'K';
  return '$'+v.toFixed(0);
}

function bucket(ts) {
  return Math.floor(ts / (bucketSeconds * 1000)) * (bucketSeconds * 1000);
}

function rebuildHistory() {
  const keys = Object.keys(EXCHANGES);
  const cvdH = {}, priceH = [];

  keys.forEach(id => {
    cvdH[id] = [];
    const trades = rawTrades[id] || [];
    let cum = 0, lastB = -1;
    for (const t of trades) {
      cum += t.isBuy ? (t.p * t.q) : -(t.p * t.q);
      const b = bucket(t.t);
      if (b === lastB && cvdH[id].length > 0) {
        cvdH[id][cvdH[id].length-1].v = cum;
      } else {
        cvdH[id].push({ t: b, v: cum });
        lastB = b;
      }
    }
    cvdData[id] = cum;
    if (cvdH[id].length > MAX_PTS) cvdH[id] = cvdH[id].slice(-MAX_PTS);
  });

  const bt = rawTrades.binance || [];
  let lastPB = -1;
  for (const t of bt) {
    const b = bucket(t.t);
    if (b === lastPB && priceH.length > 0) {
      priceH[priceH.length-1].v = t.p;
    } else {
      priceH.push({ t: b, v: t.p });
      lastPB = b;
    }
  }
  if (priceH.length > MAX_PTS) priceH.splice(0, priceH.length - MAX_PTS);
  return { cvdH, priceH };
}

// ============================================================
// CHARTS
// ============================================================
const cDef = {
  responsive: true, maintainAspectRatio: false, animation: false,
  plugins: {
    legend: { display: false },
    tooltip: {
      backgroundColor:'#16161f', borderColor:'#252535', borderWidth:1,
      titleFont:{family:"'JetBrains Mono'",size:11},
      bodyFont:{family:"'JetBrains Mono'",size:11},
      padding:10, cornerRadius:6,
    },
  },
  scales: {
    x: {
      type:'linear', display:true,
      grid:{color:'rgba(255,255,255,0.04)',drawBorder:false},
      ticks:{
        font:{family:"'JetBrains Mono'",size:10}, color:'#55556a', maxTicksLimit:8,
        callback: v => {
          const d=new Date(v);
          return d.getHours().toString().padStart(2,'0')+':'+
                 d.getMinutes().toString().padStart(2,'0')+':'+
                 d.getSeconds().toString().padStart(2,'0');
        }
      },
    },
    y: {
      grid:{color:'rgba(255,255,255,0.04)',drawBorder:false},
      ticks:{font:{family:"'JetBrains Mono'",size:10},color:'#55556a'},
    }
  }
};

const priceChart = new Chart(document.getElementById('priceChart').getContext('2d'), {
  type:'line',
  data:{datasets:[{data:[],borderColor:'#e8e8ef',borderWidth:1.5,pointRadius:0,
    fill:{target:'origin',above:'rgba(0,230,118,0.05)',below:'rgba(255,23,68,0.05)'},tension:0.1}]},
  options:{...cDef,parsing:{xAxisKey:'t',yAxisKey:'v'},
    scales:{...cDef.scales,y:{...cDef.scales.y,
      ticks:{...cDef.scales.y.ticks,callback:v=>v>=1000?'$'+v.toLocaleString():'$'+v.toFixed(2)}}}}
});

const cvdChart = new Chart(document.getElementById('cvdChart').getContext('2d'), {
  type:'line', data:{datasets:[]},
  options:{...cDef,parsing:{xAxisKey:'t',yAxisKey:'v'},
    scales:{...cDef.scales,y:{...cDef.scales.y,
      ticks:{...cDef.scales.y.ticks,callback:v=>fmt$(v)}}},
    plugins:{...cDef.plugins,
      zoom:{pan:{enabled:true,mode:'x'},zoom:{wheel:{enabled:true},pinch:{enabled:true},mode:'x'}}}}
});

function initDatasets() {
  cvdChart.data.datasets = Object.entries(EXCHANGES).map(([id,ex])=>({
    label:ex.name,data:[],borderColor:ex.color,
    borderWidth:1.5,pointRadius:0,tension:0.2,hidden:hiddenExchanges.has(id),
  }));
}
initDatasets();

// ============================================================
// LEGEND
// ============================================================
function renderLegend() {
  const c = document.getElementById('exchangeLegend');
  c.innerHTML = '';
  Object.entries(EXCHANGES).forEach(([id,ex]) => {
    const val = cvdData[id]||0;
    const el = document.createElement('div');
    el.className = 'legend-item'+(hiddenExchanges.has(id)?' hidden':'');
    el.innerHTML = `<div class="legend-dot" style="background:${ex.color}"></div>
      <span class="legend-name">${ex.name}</span>
      <span class="legend-value ${val>=0?'positive':'negative'}">${fmt$(val)}</span>`;
    el.addEventListener('click', () => {
      hiddenExchanges.has(id)?hiddenExchanges.delete(id):hiddenExchanges.add(id);
      renderLegend();
      const idx = Object.keys(EXCHANGES).indexOf(id);
      if(cvdChart.data.datasets[idx]){
        cvdChart.data.datasets[idx].hidden = hiddenExchanges.has(id);
        cvdChart.update('none');
      }
    });
    c.appendChild(el);
  });
}
renderLegend();

// ============================================================
// PROCESS TRADE
// ============================================================
function addTrade(exId, price, qty, isBuy, ts) {
  if(!rawTrades[exId]) rawTrades[exId]=[];
  rawTrades[exId].push({t:ts||Date.now(), p:price, q:qty, isBuy});
  if(rawTrades[exId].length > MAX_RAW)
    rawTrades[exId] = rawTrades[exId].slice(-MAX_RAW*0.8|0);

  const delta = isBuy ? price*qty : -(price*qty);
  if(!cvdData[exId]) cvdData[exId]=0;
  cvdData[exId] += delta;

  if(exId==='binance'){
    currentPrice = price;
    if(!startPrice) startPrice = price;
  }
  tradeCount++;
}

// ============================================================
// REST API - HISTORICAL
// ============================================================
async function loadHistory() {
  document.getElementById('priceLoading').classList.remove('hidden');
  document.getElementById('cvdLoading').classList.remove('hidden');
  const coin = activeCoin;
  const jobs = [];

  // BINANCE
  jobs.push((async()=>{
    try{
      const r = await fetch(`https://api.binance.com/api/v3/trades?symbol=${COINS[coin].binance.rest}&limit=1000`);
      const d = await r.json();
      d.forEach(t=>addTrade('binance',parseFloat(t.price),parseFloat(t.qty),!t.isBuyerMaker,t.time));
      console.log('Binance:',d.length,'trades loaded');
    }catch(e){console.warn('Binance REST:',e);}
  })());

  // BYBIT
  jobs.push((async()=>{
    try{
      const r = await fetch(`https://api.bybit.com/v5/market/recent-trade?category=spot&symbol=${COINS[coin].bybit.rest}&limit=1000`);
      const d = await r.json();
      if(d.result&&d.result.list){
        const trades = d.result.list.reverse();
        trades.forEach(t=>addTrade('bybit',parseFloat(t.price),parseFloat(t.size),t.side==='Buy',parseInt(t.time)));
        console.log('Bybit:',trades.length,'trades loaded');
      }
    }catch(e){console.warn('Bybit REST:',e);}
  })());

  // KRAKEN
  jobs.push((async()=>{
    try{
      const r = await fetch(`https://api.kraken.com/0/public/Trades?pair=${COINS[coin].kraken.rest}&count=1000`);
      const d = await r.json();
      if(d.result){
        const key = Object.keys(d.result).find(k=>k!=='last');
        if(key&&d.result[key]){
          const trades = d.result[key];
          trades.forEach(t=>{
            addTrade('kraken',parseFloat(t[0]),parseFloat(t[1]),t[3]==='b',Math.floor(parseFloat(t[2])*1000));
          });
          console.log('Kraken:',trades.length,'trades loaded');
        }
      }
    }catch(e){console.warn('Kraken REST:',e);}
  })());

  // COINBASE
  jobs.push((async()=>{
    try{
      const r = await fetch(`https://api.exchange.coinbase.com/products/${COINS[coin].coinbase.rest}/trades?limit=1000`);
      const d = await r.json();
      if(Array.isArray(d)){
        const trades = d.reverse();
        trades.forEach(t=>{
          addTrade('coinbase',parseFloat(t.price),parseFloat(t.size),t.side==='sell',new Date(t.time).getTime());
        });
        console.log('Coinbase:',trades.length,'trades loaded');
      }
    }catch(e){console.warn('Coinbase REST:',e);}
  })());

  await Promise.allSettled(jobs);
  document.getElementById('priceLoading').classList.add('hidden');
  document.getElementById('cvdLoading').classList.add('hidden');
}

// ============================================================
// WEBSOCKETS
// ============================================================
async function connectAll() {
  disconnectAll();
  connectedCount = 0;
  Object.keys(EXCHANGES).forEach(id=>{cvdData[id]=0;rawTrades[id]=[];});
  currentPrice=0; startPrice=0; tradeCount=0;

  await loadHistory();
  connectBinance(); connectBybit(); connectKraken(); connectCoinbase();
}

function disconnectAll() {
  Object.values(sockets).forEach(ws=>{try{ws.close();}catch(e){}});
  sockets={};
}

function updateStatus() {
  const dot=document.getElementById('statusDot'), txt=document.getElementById('statusText');
  const total=Object.keys(EXCHANGES).length;
  if(connectedCount>0){
    dot.className='status-dot connected';
    txt.textContent=`${connectedCount}/${total} 거래소 연결됨`;
  }else{
    dot.className='status-dot'; txt.textContent='연결 중...';
  }
}

function connectBinance(){
  const ws=new WebSocket(`wss://stream.binance.com:9443/ws/${COINS[activeCoin].binance.ws}`);
  sockets.binance=ws;
  ws.onopen=()=>{connectedCount++;updateStatus();};
  ws.onclose=()=>{connectedCount=Math.max(0,connectedCount-1);updateStatus();};
  ws.onmessage=(e)=>{
    const d=JSON.parse(e.data);
    if(d.e==='trade') addTrade('binance',parseFloat(d.p),parseFloat(d.q),!d.m,d.T);
  };
  ws.onerror=()=>{};
}

function connectBybit(){
  const ws=new WebSocket('wss://stream.bybit.com/v5/public/spot');
  sockets.bybit=ws;
  ws.onopen=()=>{
    connectedCount++;updateStatus();
    ws.send(JSON.stringify({op:'subscribe',args:[COINS[activeCoin].bybit.ws]}));
  };
  ws.onclose=()=>{connectedCount=Math.max(0,connectedCount-1);updateStatus();};
  ws.onmessage=(e)=>{
    const m=JSON.parse(e.data);
    if(m.topic&&m.topic.startsWith('publicTrade')&&m.data){
      m.data.forEach(t=>addTrade('bybit',parseFloat(t.p),parseFloat(t.v),t.S==='Buy',parseInt(t.T)));
    }
  };
  ws.onerror=()=>{};
}

function connectKraken(){
  const ws=new WebSocket('wss://ws.kraken.com/v2');
  sockets.kraken=ws;
  ws.onopen=()=>{
    connectedCount++;updateStatus();
    ws.send(JSON.stringify({method:'subscribe',params:{channel:'trade',symbol:[COINS[activeCoin].kraken.ws]}}));
  };
  ws.onclose=()=>{connectedCount=Math.max(0,connectedCount-1);updateStatus();};
  ws.onmessage=(e)=>{
    const m=JSON.parse(e.data);
    if(m.channel==='trade'&&m.data){
      m.data.forEach(t=>{
        addTrade('kraken',parseFloat(t.price),parseFloat(t.qty),t.side==='buy',new Date(t.timestamp).getTime());
      });
    }
  };
  ws.onerror=()=>{};
}

function connectCoinbase(){
  const ws=new WebSocket('wss://ws-feed.exchange.coinbase.com');
  sockets.coinbase=ws;
  ws.onopen=()=>{
    connectedCount++;updateStatus();
    ws.send(JSON.stringify({type:'subscribe',product_ids:[COINS[activeCoin].coinbase.ws],channels:['matches']}));
  };
  ws.onclose=()=>{connectedCount=Math.max(0,connectedCount-1);updateStatus();};
  ws.onmessage=(e)=>{
    const m=JSON.parse(e.data);
    if(m.type==='match'||m.type==='last_match'){
      addTrade('coinbase',parseFloat(m.price),parseFloat(m.size),m.side==='sell',new Date(m.time).getTime());
    }
  };
  ws.onerror=()=>{};
}

// ============================================================
// UI LOOP
// ============================================================
function updateUI(){
  const{cvdH,priceH}=rebuildHistory();

  const priceEl=document.getElementById('currentPrice');
  const changeEl=document.getElementById('priceChange');
  if(currentPrice>0){
    priceEl.textContent='$'+currentPrice.toLocaleString(undefined,{
      minimumFractionDigits:activeCoin==='SOL'?2:1,
      maximumFractionDigits:activeCoin==='SOL'?2:1});
    if(startPrice>0){
      const pct=((currentPrice-startPrice)/startPrice*100).toFixed(2);
      const diff=currentPrice-startPrice;
      changeEl.textContent=`${diff>=0?'+':''}$${diff.toFixed(1)} (${pct}%)`;
      changeEl.className='price-change '+(diff>=0?'up':'down');
    }
  }

  priceChart.data.datasets[0].data=priceH;
  priceChart.update('none');

  Object.keys(EXCHANGES).forEach((id,i)=>{
    if(cvdChart.data.datasets[i]) cvdChart.data.datasets[i].data=cvdH[id]||[];
  });
  cvdChart.update('none');

  renderLegend();

  const total=Object.values(cvdData).reduce((a,b)=>a+b,0);
  document.getElementById('totalCvd').textContent=fmt$(total);
  document.getElementById('totalCvd').className='info-value '+(total>=0?'positive':'negative');

  let topB={n:'--',v:0},topS={n:'--',v:0};
  Object.entries(cvdData).forEach(([id,val])=>{
    if(val>topB.v) topB={n:EXCHANGES[id].name,v:val};
    if(val<topS.v) topS={n:EXCHANGES[id].name,v:val};
  });
  document.getElementById('topBuyer').textContent=topB.n+' '+fmt$(topB.v);
  document.getElementById('topSeller').textContent=topS.n+' '+fmt$(topS.v);
  document.getElementById('tradeCount').textContent=tradeCount.toLocaleString();
}

setInterval(updateUI,1000);

// ============================================================
// EVENTS
// ============================================================
document.querySelectorAll('.coin-tab').forEach(btn=>{
  btn.addEventListener('click',()=>{
    document.querySelectorAll('.coin-tab').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    activeCoin=btn.dataset.coin;
    document.getElementById('priceLabel').textContent=`${activeCoin}/USDT · Binance Reference`;
    connectAll();
  });
});

document.querySelectorAll('.timeframe-btn').forEach(btn=>{
  btn.addEventListener('click',()=>{
    document.querySelectorAll('.timeframe-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    bucketSeconds=parseInt(btn.dataset.bucket);
  });
});

document.getElementById('resetBtn').addEventListener('click',()=>{
  Object.keys(EXCHANGES).forEach(id=>{cvdData[id]=0;rawTrades[id]=[];});
  startPrice=currentPrice; tradeCount=0;
});

// ============================================================
// INIT
// ============================================================
connectAll();
</script>
</body>
</html>
